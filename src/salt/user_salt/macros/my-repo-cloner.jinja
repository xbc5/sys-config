{#
You MUST do includes on your own. This relies on a project state that ensures the storage location for your repo exists. It also depends on Git.

state_name:   The name without a verb -- e.g. foo-bar, not foo-bar-cloned. This macro appends verbs.
user:         The user name for the local account -- it will become the owner of the repo, and the account that runs the git command.
proj_include: The name of the dependency that creates the project folder -- e.g. 'linux-proj-dir-created' from `states.fs.projects.guest`. You can responsible for including the those state files yourself.
store_path:   The FULL path (including repo dir name) where the repo lives -- typically under your projects directory.
app_path:     The directory where the main app data lives. Since we clone into the projects store, which directory in the file system should it link from? For example, for nvim it's ~/.config/nvim. This becomes a symlink that points to the repo.
git_https:    The https link for the repo. This is for cloning without credentials.
git_ssh:      The Git URL for the repo (e.g. git@github.com). It is set on the repo as a remote after cloning.

#}
{% macro clone(prefs) %}
include:
  - states.fs.projects.guest # store repo here
  - states.nvim.core.guest # clone packer

{{ prefs.state_name }}-cloned:
  git.cloned:
    - require:
      - {{ prefs.proj_include }}
    - name: {{ prefs.git_https }}
    - target: {{ prefs.store_path }}
    - user: {{ prefs.user }}
  cmd.run:
    - name: git remote set-url origin {{ prefs.git_ssh }}
    - runas: {{ prefs.user }}
    - cwd: {{ prefs.store_path }}
  file.directory:
    - name: {{ prefs.store_path }}
    - user: {{ prefs.user }}
    - group: {{ prefs.user }}
    - recurse:
      - user
      - group

{{ prefs.state_name }}-linked:
  file.symlink:
    - require:
      - {{ prefs.state_name }}-cloned
    - name: {{ prefs.app_path }}
    - target: {{ prefs.store_path }}
    - force: True
    - makedirs: True
    - user: {{ prefs.user }}
    - group: {{ prefs.user }}
{% endmacro %}
